# -*- coding: utf-8 -*-
"""06_funnel_analysis_template-level_lift_latency_curves_causal_forest

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lq3JMD8y3C-a8AwTp5_oNbF1eBqNynCy
"""

import numpy as np
import pandas as pd

# 1. normalise segment labels
for df in [exp_funding_merge_df, open_rate_TS_df]:
    df["group_name"] = (
        df["group_name"]
          .str.strip()        # remove leading / trailing spaces
          .str.lower()        # optional: make case-insensitive
    )

# 2. compute max open-rate per group (numeric only)
day_cols = [c for c in open_rate_TS_df.columns if c.startswith("order_")]

open_rate_grp = (
    open_rate_TS_df
      .set_index("group_name")[day_cols]
      .apply(pd.to_numeric, errors="coerce")  # ensure floats
      .max(axis=1)                            # best-day open rate
      .fillna(0)                              # if a group never got an email
      .rename("max_email_open_rate")
      .to_frame()
)

# 3. build funnel table & join open-rate
funnel_cols = [
    "group_name", "link_rate", "act_rate", "funding_rate",
    "link_rate_in_control", "funding_rate_in_control",
    "delta_link_rate", "delta_fund_rate"
]

rate_funnel_df = (
    exp_funding_merge_df[funnel_cols]
      .set_index("group_name")
      .join(open_rate_grp, how="left")
)

# 4. derived metrics (no divide-by-zero)
rate_funnel_df["delta_rate_funnel"] = (
    rate_funnel_df["max_email_open_rate"] - rate_funnel_df["funding_rate"])

rate_funnel_df["extra_conversion_rate"] = (
    rate_funnel_df["delta_fund_rate"] /
    rate_funnel_df["max_email_open_rate"].replace(0, np.nan))

# fill any remaining NaN with 0 for clarity
rate_funnel_df = rate_funnel_df.fillna(0)

rate_funnel_df.head()

import matplotlib.pyplot as plt

vals = rate_funnel_df.loc["20d_act_d", ["max_email_open_rate",
                                        "link_rate",
                                        "funding_rate"]]

labels = ["Open", "Link", "Fund"]
plt.figure(figsize=(4,6))
plt.barh(labels, vals, color=["#4c72b0", "#55a868", "#c44e52"])
plt.gca().invert_yaxis()           # largest at top
for y, v in enumerate(vals):
    plt.text(v + 0.005, y, f"{v:.1%}", va="center")
plt.xlim(0, vals.max()*1.2)
plt.title("Segment 20D_Act_D – funnel")
plt.show()

vals = rate_funnel_df.loc["20d_act_d", ["max_email_open_rate",
                                        "link_rate",
                                        "funding_rate"]]
drops = vals.diff().fillna(vals.iloc[0])          # first bar = opens
drops.iloc[1:] = drops.iloc[1:]                   # negative values

plt.figure(figsize=(6,4))
plt.bar(labels, drops, color=["#4c72b0", "#dd8452", "#c44e52"])
plt.title("Loss at each step (absolute %)")
plt.show()

temp =rate_funnel_df.sort_values('delta_rate_funnel')#,ascending=False)
temp

#temp =rate_funnel_df#[rate_funnel_df['link_rate']<1].sort_values('delta_link_rate',ascending=False)
temp =rate_funnel_df.sort_values('delta_fund_rate',ascending=False)

num_list = temp.select_dtypes(include=np.number).columns.tolist()
temp[num_list] = temp[num_list]*100

ax = temp.plot(y=["max_email_open_rate", "link_rate", "funding_rate"], kind="bar",figsize=(16, 12))

plt.xticks(fontsize=20)
plt.yticks(fontsize=20)
plt.ylabel('Rate (%)',fontsize=20)
plt.title('Email Open Rate -> Link Rate -> Funding Rate (sorted by delta funding rate)',fontsize=22)

plt.legend(fontsize=20)
plt.grid(which='both', color='0.65', linestyle='-')

ax2=ax.twinx()
ax2.plot(temp['delta_fund_rate'],color="green",marker="o")

#ax = temp['delta_fund_rate'].plot(secondary_y=True, color='k', marker='o',figsize=(16, 12))
ax2.set_ylabel('size')
plt.yticks(fontsize=20)
plt.ylabel('delta funding rate (%)',fontsize=20)

plt.show()

#temp =rate_funnel_df#[rate_funnel_df['link_rate']<1].sort_values('delta_link_rate',ascending=False)
temp =rate_funnel_df.sort_values('extra_conversion_rate',ascending=False)

num_list = temp.select_dtypes(include=np.number).columns.tolist()
temp[num_list] = temp[num_list]*100

ax = temp.plot(y=["max_email_open_rate", "funding_rate","funding_rate_in_control"], kind="bar",figsize=(16, 12))

plt.xticks(fontsize=20)
plt.yticks(fontsize=20)
plt.ylabel('Rate (%)',fontsize=20)
plt.title('Email Open Rate -> Funding Rate (sorted by extra conversion rate)',fontsize=22)

plt.legend(fontsize=20)
plt.grid(which='both', color='0.65', linestyle='-')

ax2=ax.twinx()
ax2.plot(temp['extra_conversion_rate'],color="green",marker="o")

#ax = temp['delta_fund_rate'].plot(secondary_y=True, color='k', marker='o',figsize=(16, 12))
ax2.set_ylabel('size')
plt.yticks(fontsize=20)
plt.ylabel('extra conversion rate (%)',fontsize=20)

plt.show()

#temp =rate_funnel_df#[rate_funnel_df['link_rate']<1].sort_values('delta_link_rate',ascending=False)
temp =rate_funnel_df.sort_values('delta_rate_funnel')#,ascending=False)

num_list = temp.select_dtypes(include=np.number).columns.tolist()
temp[num_list] = temp[num_list]*100

ax = temp.plot(
        y=["max_email_open_rate", "funding_rate", "funding_rate_in_control"],
        kind="bar",
        figsize=(16, 12)
)

plt.xticks(fontsize=20)
plt.yticks(fontsize=20)
plt.ylabel('Rate (%)',fontsize=20)
plt.title('Email Open Rate -> Funding Rate (sorted by funnel delta)',fontsize=22)

plt.legend(fontsize=20)
plt.grid( which='both', color='0.65', linestyle='-')

ax2=ax.twinx()
ax2.plot(temp['delta_rate_funnel'],color="green",marker="o")

#ax = temp['delta_fund_rate'].plot(secondary_y=True, color='k', marker='o',figsize=(16, 12))
ax2.set_ylabel('size')
plt.yticks(fontsize=20)
plt.ylabel('funnel delta (%)',fontsize=20)

plt.show()

"""segment_group_init_df = pd.read_csv('/content/drive/MyDrive/Email_project/sample_segment_groups.csv')

"""

from google.colab import drive
drive.mount('/content/drive')
groups      = pd.read_csv('/content/drive/MyDrive/Email_project/sample_segment_groups.csv')         # seg rules
schedule    = pd.read_csv("/content/drive/MyDrive/Email_project/sample_uuid_email_order.csv")        # delivery plan
email_evts  = pd.read_csv("/content/drive/MyDrive/Email_project/email_event_TS.csv")                   # optional raw events
user_evts   = pd.read_csv("/content/drive/MyDrive/Email_project/user_events.csv", parse_dates=[
                    "approved_at","first_funded_at","first_linked_bank_account_at"
                ])
control     = pd.read_csv("/content/drive/MyDrive/Email_project/control_groups_rate.csv")

user_evts

"""# Template-level lift: Which email actually works?"""

tmpl_cols = [c for c in user_evts.columns if c.startswith("ml_")]
tmpl_long = (
    user_evts.melt(id_vars=["user_uuid","group_name"],
                   value_vars=tmpl_cols,
                   var_name="template", value_name="evt")
             .dropna(subset=["evt"])
)
funded_map = (
    user_evts.drop_duplicates("user_uuid")          # guard against dups
             .set_index("user_uuid")["first_funded_at"]
             .notna()                               # True if timestamp exists
             .astype(int)                           # 1 / 0
)

tmpl_long = tmpl_long.merge(
    funded_map.rename("funded"),          # becomes a new column
    left_on="user_uuid", right_index=True, how="left"
).fillna({"funded": 0})                  # users not in map → 0


tmpl_long["delivered"]  = 1
tmpl_long["opened"]     = tmpl_long["evt"].eq("open").astype(int)
tmpl_long["spam"]       = tmpl_long["evt"].eq("spamreport").astype(int)
tmpl_long["unsub"]      = tmpl_long["evt"].eq("unsubscribe").astype(int)


template_stats = (
    tmpl_long.groupby("template")[["delivered","opened","funded","spam","unsub"]]
             .sum()
             .assign(
                 open_rate  = lambda d: d["opened"] / d["delivered"],
                 fund_rate  = lambda d: d["funded"] / d["delivered"],
                 spam_rate  = lambda d: d["spam"]  / d["delivered"],
                 unsub_rate = lambda d: d["unsub"] / d["delivered"]
             )
)

# control lift
ctrl_map = control.set_index("group_name")["funding_rate_in_control"].to_dict()
template_stats["fund_rate_control"] = tmpl_long["group_name"].map(ctrl_map).fillna(0)
template_stats["delta_fund_rate"]   = template_stats["fund_rate"] - template_stats["fund_rate_control"]

template_stats = (
    template_stats[["delivered","opened","funded","open_rate","fund_rate",
                    "fund_rate_control","delta_fund_rate","spam_rate","unsub_rate"]]
    .sort_values("delta_fund_rate", ascending=False)
)

print(template_stats.head())

"""# Model time-to-link and time-to-fund after an open: How long should we wait before sending a second nudge?"""

from lifelines import KaplanMeierFitter
import matplotlib.pyplot as plt

km = KaplanMeierFitter()
durations = (user_evts["first_funded_at"] - user_evts["approved_at"]).dt.days # time delta in days
event_observed = user_evts["first_funded_at"].notna().astype(int)

km.fit(durations.fillna(durations.max()+1), event_observed)
km.plot_survival_function(ci_show=False)
plt.title("Survival – probability user has NOT funded since approval")
plt.xlabel("Days since approval"); plt.ylabel("P(still unfunded)")
plt.show()

!pip install scikit-uplift

from sklift.models import SoloModel
from sklearn.ensemble import RandomForestClassifier
from sklift.metrics import qini_auc_score

assert "group_name" in user_evts.columns

treatment = (
    user_evts["group_name"]
        .str.contains("control", case=False, na=False)   # True for control rows
        .map({True: 0, False: 1})                        # control→0, treatment→1
        .astype(int)
)


features = user_evts[["5d_trading_avg_event_count",
                      "20d_trading_avg_event_count",
                      "1d_non_trading_avg_event_count"]].fillna(0)

outcome = user_evts["first_funded_at"].notna().astype(int)

uplift_clf = SoloModel(RandomForestClassifier(n_estimators=300, max_depth=6, random_state=42))
uplift_clf.fit(features, outcome, treatment)

# uplift scores  (ΔP(fund | treat=1) − P(fund | treat=0))
uplift_scores = uplift_clf.predict(features)          # <- correct call
# alternatively:
# proba_treat, proba_ctrl = uplift_clf.predict_proba(features).T
# uplift_scores = proba_treat - proba_ctrl

from sklift.metrics import qini_auc_score
print("Qini AUC:", qini_auc_score(outcome, uplift_scores, treatment))
print("Qini AUC:", qini_auc_score(outcome, uplift_scores, treatment))