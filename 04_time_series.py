# -*- coding: utf-8 -*-
"""04_time_series

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M0Eb3jtOIHTGlBgeMp9bTSKX34QObPr4
"""



email_event_name_df = sample_exp_df.copy()
for d in range(len(PO_number_list)):
    email_event_name_df['order_'+str(d)] = email_event_name_df['order_'+str(d)].map(PO_number_dict)

email_event_name_df.head()

big_table_df = email_event_name_df.merge(email_date_df.drop(columns = ['group_name']),on='user_uuid', how = 'left') #every user keeps the schedule columns plus all ten status columns
big_table_df.head()

def update_event(in_df):
    out_df = in_df[['user_uuid','group_name']]
    for d in range(10):
        out_df['order_' + str(d)] = in_df[in_df['order_'+str(d)]]
    return out_df

import time

tic = time.perf_counter()          # start timer

email_event_TS_df = big_table_df.apply(update_event, axis=1)

toc = time.perf_counter()          # stop timer
print(f"run time: {toc - tic:.2f} seconds")

email_event_TS_df.head()

email_event_TS_df.to_csv('/content/drive/MyDrive/Email_project/email_event_TS.csv')
day_list = []
for i in range(len(PO_number_list)):
    day_list.append('order_' + str(i))

#delivered_count_df = user_event_df.drop(columns=['user_uuid'])
delivered_count_TS_df = email_event_TS_df[['user_uuid','group_name']+day_list]
for e in day_list:
    delivered_count_TS_df[e] = delivered_count_TS_df[e].notnull()

delivered_count_TS_df = delivered_count_TS_df.groupby('group_name').sum().reset_index()
delivered_count_TS_df.head()

"""## 2. Check if the experiment has finished.

Apparently, the experiment is no finished as the '*_W' users have not received their last Email (order_9) yet.
"""

day_cols = [c for c in delivered_count_TS_df.columns if c.startswith("order_")]

numeric = (
    delivered_count_TS_df
      .set_index("group_name")[day_cols]
      .replace({True: 1, False: 0})              # if still bool
      .apply(pd.to_numeric, errors="coerce")     # turn bad strings → NaN
)

# 2️⃣  plot
plt.figure(figsize=(20, 10))
sns.heatmap(numeric, annot=True, fmt=".0f", cmap="viridis")
plt.title("Delivered-email counts per group and send-slot")
plt.show()

#open_count_df = user_event_df.drop(columns=['user_uuid'])
open_count_TS_df = email_event_TS_df[['user_uuid','group_name']+day_list]
for e in day_list:
    open_count_TS_df[e] = open_count_TS_df[e] == 'open'

open_count_TS_df = open_count_TS_df.groupby('group_name').sum().reset_index()
open_count_TS_df.head()

open_rate_TS_df = open_count_TS_df
for e in day_list:
    open_rate_TS_df[e] = open_count_TS_df[e]/delivered_count_TS_df[e]

"""## 3. Check heatmap for Email open rate according to the order they were sent.

One possible strategy for future Email experiment is to send 2-3 Emails, as the second Email intents to have a higher open rate.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# -------------------------- pick the day columns --------------------------
day_cols = [c for c in open_rate_TS_df.columns if c.startswith("order_")]

# keep group_name + numeric day columns only
numeric = (
    open_rate_TS_df[["group_name"] + day_cols]
      .set_index("group_name")
      # if open‐rate is stored as bools (True=opened) convert -> 0/1
      .replace({True: 1, False: 0})
      # force anything that still looks like text to NaN
      .apply(pd.to_numeric, errors="coerce")
)

# -------------------------- heat-map --------------------------
plt.figure(figsize=(20, 10))
sns.heatmap(
    numeric,               # all-numeric matrix
    annot=True,
    fmt=".2f",             # show 0.87 not 8.7e-01
    cmap="viridis"
)
plt.xticks(fontsize=14)
plt.yticks(fontsize=14)
plt.title("Heat-map of email open-rate (time series)", fontsize=18)
plt.tight_layout()
plt.show()